---
phase: 01-performance-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/build.gradle.kts
  - .planning/phases/01-performance-fix/01-FINDINGS.md
autonomous: true

must_haves:
  truths:
    - "LeakCanary is installed and functional in debug builds"
    - "Memory profiling session captured heap dumps over 30+ minute period"
    - "Performance issues are identified and documented with evidence"
  artifacts:
    - path: ".planning/phases/01-performance-fix/01-FINDINGS.md"
      provides: "Documented performance issues with profiler evidence"
      contains: "## Issues Found"
  key_links:
    - from: "app/build.gradle.kts"
      to: "debugImplementation(leakcanary)"
      via: "dependency declaration"
      pattern: "leakcanary"
---

<objective>
Set up performance investigation tooling and conduct comprehensive profiling session to identify root causes of UI stuttering and progressive degradation.

Purpose: Establish diagnostic foundation and systematically identify all performance issues before attempting fixes.
Output: LeakCanary integration + FINDINGS.md documenting all discovered issues with profiler evidence.
</objective>

<execution_context>
@/home/tyler/.claude/get-shit-done/workflows/execute-plan.md
@/home/tyler/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-performance-fix/01-CONTEXT.md
@.planning/phases/01-performance-fix/01-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md
@app/build.gradle.kts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add LeakCanary dependency for automated leak detection</name>
  <files>app/build.gradle.kts</files>
  <action>
Add LeakCanary as a debugImplementation dependency for automated memory leak detection.

1. In the dependencies block of app/build.gradle.kts, add:
   ```kotlin
   debugImplementation("com.squareup.leakcanary:leakcanary-android:2.14.0")
   ```

2. Verify the dependency integrates with the existing Hilt DI setup (LeakCanary auto-initializes, no code changes needed).

3. Run `./gradlew :app:assembleDebug` to verify the build succeeds with the new dependency.

Why LeakCanary: It automatically detects Activity, Fragment, ViewModel, and Service leaks without manual heap dump analysis. The progressive degradation reported in #340 strongly suggests a memory leak, and LeakCanary will surface it automatically during testing.

Note: This is a debug-only dependency with zero production impact. LeakCanary does NOT run in release builds.
  </action>
  <verify>
1. `./gradlew :app:dependencies --configuration debugRuntimeClasspath | grep leakcanary` shows the dependency
2. `./gradlew :app:assembleDebug` builds successfully
3. No new lint errors introduced
  </verify>
  <done>LeakCanary 2.14.0 is added to debug builds and app compiles successfully.</done>
</task>

<task type="auto">
  <name>Task 2: Conduct profiling session and document findings</name>
  <files>.planning/phases/01-performance-fix/01-FINDINGS.md</files>
  <action>
Conduct a comprehensive profiling session using Android Studio Profiler and LeakCanary to identify all performance issues. This task follows the profiler-first investigation workflow from research.

**Profiling Session Protocol:**

1. **Setup:**
   - Build and install debug APK on connected device: `./gradlew :app:installDebug`
   - Open Android Studio Profiler (View → Tool Windows → Profiler)
   - Attach to `com.lxmf.messenger` process
   - Enable CPU profiler (Sample Java Methods) and Memory profiler (Track allocations)

2. **Baseline Capture (T=0):**
   - Navigate to Interface Discovery screen
   - Wait 5 seconds for initial load
   - Capture heap dump #1 (baseline)
   - Note: frame timing, allocation rate, heap size

3. **Scroll Test:**
   - Scroll the discovered interfaces list up and down for 60 seconds
   - Look for: janky frames (>16ms), excessive allocations, GC pressure
   - Record: CPU profiler method trace during scroll

4. **Soak Test (30 minutes):**
   - Leave app on Interface Discovery screen
   - Every 10 minutes: capture heap dump, note heap size growth
   - If LeakCanary notification appears: capture leak trace

5. **Comparison Test (without Discovery):**
   - Disable Interface Discovery (if possible) or navigate away
   - Run for 15 minutes, capture heap dump
   - Compare: Is heap growth similar or different?

6. **Multi-Screen Test:**
   - Navigate to: Chats, Contacts, Settings screens
   - Brief profiling (2-3 minutes each)
   - Note: Any screens with similar issues?

**Create FINDINGS.md with:**

```markdown
# Phase 1: Performance Investigation Findings

**Date:** {date}
**Device:** {device model}
**Build:** debug

## Executive Summary

[1-2 sentence summary of findings]

## Issues Found

### Issue 1: {Name}

**Severity:** HIGH/MEDIUM/LOW
**Type:** Memory Leak / Compose Recomposition / Main Thread Blocking / Other
**Evidence:**
- [Profiler screenshot or data point]
- [Heap dump comparison]
- [Code location if identifiable]

**Root Cause Analysis:**
[What's happening and why]

**Proposed Fix:**
[Specific code change needed]

### Issue 2: {Name}
...

## Profiling Data

### Memory Growth

| Time | Heap Size | Retained Objects | Notes |
|------|-----------|------------------|-------|
| T=0  | X MB      | N                | Baseline |
| T=10 | X MB      | N                | ... |
| T=20 | X MB      | N                | ... |
| T=30 | X MB      | N                | ... |

### Frame Timing (Scroll Test)

- Average frame time: X ms
- 90th percentile: X ms
- Janky frames (>16ms): N%

### LeakCanary Reports

[List any leaks detected, or "None detected"]

## Comparison: With vs Without Discovery

[Summary of comparison test results]

## Additional Observations

[Anything else noticed during investigation]
```

**Important constraints (from user decisions):**
- Use profiler only - do NOT add temporary logging statements to code
- Document all issues found, not just the first one
- If issue is in Python/Chaquopy, note it - fix will involve forking Reticulum
  </action>
  <verify>
1. 01-FINDINGS.md exists with all required sections
2. At least one issue is documented (or explicit statement that no issues found)
3. Memory profiling data includes 30+ minute timeline
4. Evidence is concrete (heap sizes, frame times, leak traces)
  </verify>
  <done>FINDINGS.md documents all discovered performance issues with profiler evidence, heap dump timeline, and proposed fixes.</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. LeakCanary appears in debug APK (`./gradlew :app:dependencies` shows it)
2. 01-FINDINGS.md contains documented issues with evidence
3. Proposed fixes are specific enough for Plan 02 implementation
</verification>

<success_criteria>
- LeakCanary 2.14.0 integrated into debug builds
- 30+ minute profiling session completed
- All performance issues documented with root cause analysis
- Proposed fixes are actionable (specific files and changes)
</success_criteria>

<output>
After completion, create `.planning/phases/01-performance-fix/01-01-SUMMARY.md` documenting:
- LeakCanary integration
- Number and severity of issues found
- Key findings that will drive Plan 02
</output>
